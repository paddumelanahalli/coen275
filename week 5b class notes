Object-Oriented Analysis, Design, and Programming


Week 5b: Objects and Object-Oriented Concepts


I. Introduction (5 minutes)


Briefly introduce the concept of object-oriented programming (OOP) and its importance.
Mention the key principles: Abstraction, Encapsulation, Modularity, Hierarchy, Typing, Concurrency, and Persistence.
Explain that OOA, OOD, and OOP are different but related stages in software development.

II. Objects and Classes (15 minutes)


Object Definition:
State: Attributes that describe the object.
Behavior: Methods (functions) that the object can perform.
Identity: A unique way to distinguish one object from another.
Class Definition:
A blueprint or template for creating objects.
Defines the attributes and methods that objects of that class will have.
Instance: A specific object created from a class.
Example:
Class: Dog
Attributes: breed, age, color
Methods: bark(), eat(), sleep()
Instance: myDog (a specific dog object with its own breed, age, and color)

III. Object-Oriented Analysis (OOA) (20 minutes)


Definition: Examining requirements from the perspective of classes and objects in the problem domain.
Purpose: To understand the problem and create a model of how the system should function.
Key Activities:
Identifying objects and classes.
Defining attributes and behaviors.
Modeling interactions between objects.
Techniques: Object Modeling, Dynamic Modeling, Functional Modeling (explained in detail later).
UML: Briefly introduce UML as a standard notation for visualizing and documenting software systems.

IV. Object-Oriented Design (OOD) (10 minutes)


Definition: The process of object-oriented decomposition and creating models of the system.
Purpose: To create a design that meets the requirements identified during OOA.
Models: Class diagrams, object diagrams, component diagrams, deployment diagrams (briefly mention these).

V. Object-Oriented Programming (OOP) (10 minutes)


Definition: Implementing the design as a collection of interacting objects.
Key Concepts (Recap):
Encapsulation: Bundling data (attributes) and methods together within a class.
Inheritance: Creating new classes (child classes) based on existing classes (parent classes).
Polymorphism: The ability of objects to take on many forms (method overloading and overriding).
Abstraction: Hiding complex implementation details and showing only essential information.

VI. Object Modeling (20 minutes)


Purpose: To develop the static structure of the software system.
Key Elements:
Objects
Classes (groupings of objects)
Relationships between objects
Attributes and operations of each class
Principles: Abstraction, Encapsulation, Modularity, Hierarchy, Typing, Concurrency, Persistence.
UML Class Diagrams: Briefly introduce how to represent classes, attributes, and methods in a UML class diagram.

VII. Dynamic Modeling (20 minutes)


Purpose: To model the behavior of the system over time.
Key Concepts:
States: Conditions or situations that an object can be in.
Events: Triggers that cause an object to transition from one state to another.
State Diagrams (Transition Diagrams): Visual representation of states and transitions.
Types of Events:
Signal Event: An external signal triggers the event (e.g., train departure).
Change Event: A change in a value triggers the event (e.g., battery power < 10%).
Time Event: A specific time or duration triggers the event (e.g., date = Jan 1st 2022).

VIII. Functional Modeling (15 minutes)


Purpose: To describe the processes performed within the system.
Focus: Data flow, actions, and data stores.
Data Flow Diagrams (DFD):
Graphical representation of how data moves through the system.
Shows inputs, outputs, and processes.
Use Cases: Briefly mention use cases as a way to describe how users interact with the system.

IX. Recap and Q&A (5 minutes)


Summarize the key concepts covered in the lecture.
Open the floor for questions.

Notes for Expansion:


Examples: Use real-world examples to illustrate each concept. For instance, when discussing inheritance, use the example of different types of vehicles inheriting from a base "Vehicle" class.
Diagrams: Include diagrams (UML class diagrams, state diagrams, DFDs) to visually represent the concepts.
C++ Code Snippets: While a full program is not here!, include small code snippets to demonstrate how to implement basic OOP concepts in C++. For example:


// Example of a simple class
class Dog {
public:
    string breed;
    int age;

    void bark() {
        cout << "Woof!" << endl;
    }
};

int main() {
    Dog myDog;
    myDog.breed = "Labrador";
    myDog.age = 3;
    myDog.bark(); // Output: Woof!
    return 0;
}

Activities: Incorporate short activities or thought experiments to engage students. For example:
"Think of a real-world object and list its attributes and behaviors."
"Draw a simple state diagram for a traffic light."

This expanded outline provides a solid foundation for creating comprehensive class notes on object-oriented analysis, design, and programming. Remember to tailor the content and examples to your specific audience and learning objectives.


Use Case: Online Library System


Problem Statement:


A library wants to develop an online system that allows patrons to search for books, reserve books, borrow books, return books, and manage their accounts. The system should also allow librarians to add new books, update book information, and manage patron accounts.


Applying OOA Techniques:


1. Object Modeling:


Identify Objects:
Book
Patron
Librarian
Account
Reservation
Loan
Identify Classes:
Create classes corresponding to the objects above: Book, Patron, Librarian, Account, Reservation, Loan.
Define Attributes:
Book: bookID, title, author, ISBN, publicationDate, genre, availability (boolean)
Patron: patronID, name, address, phone, email, accountID
Librarian: librarianID, name, employeeID, username, password
Account: accountID, balance, creationDate, patronID
Reservation: reservationID, bookID, patronID, reservationDate, expiryDate
Loan: loanID, bookID, patronID, loanDate, dueDate, returnDate
Define Operations (Methods):
Book: getBookDetails(), updateAvailability()
Patron: searchBooks(), reserveBook(), borrowBook(), returnBook(), manageAccount()
Librarian: addBook(), updateBookInfo(), managePatronAccount(), checkOutBook(), checkInBook()
Account: getBalance(), addFunds(), payFine()
Reservation: createReservation(), cancelReservation()
Loan: createLoan(), updateLoanStatus()
Relationships:
A Patron has an Account.
A Patron can make multiple Reservations.
A Patron can have multiple Loans.
A Book can be part of multiple Reservations and Loans.
A Librarian manages Books and Patron accounts.

UML Class Diagram (Simplified):


(Imagine a UML class diagram here, showing the classes, attributes, methods, and relationships. You can use tools like draw.io or Lucidchart to create one.)


2. Dynamic Modeling:


Focus on a Key Object: Book

States:

Available: The book is on the shelf and can be borrowed.
Reserved: The book is reserved by a patron.
Loaned: The book is currently checked out by a patron.
Lost: The book is lost.
Events:

search(): A patron searches for the book.
reserve(): A patron reserves the book.
borrow(): A patron borrows the book.
return(): A patron returns the book.
lost(): The book is reported lost.
add(): A librarian adds the book to the system.
remove(): A librarian removes the book from the system.
State Diagram:

Initial State: Available
search(): Stays in Available (or displays book details).
reserve(): Transitions to Reserved.
borrow(): Transitions to Loaned.
return(): Transitions back to Available.
lost(): Transitions to Lost.
add(): Transitions to Available (if added by librarian).
remove(): (Book is removed from the system - terminal state or archived).

3. Functional Modeling:


Focus on the "Borrow Book" Functionality

Data Flow Diagram (DFD):

Patron: Initiates "Borrow Book" request.
System: Verifies Patron Account (valid, not blocked, etc.).
System: Checks Book Availability (not reserved by someone else, etc.).
System: Creates a Loan record in the database.
System: Updates Book availability to Loaned.
System: Updates Patron account with the new loan.
System: Generates a loan receipt for the Patron.
Patron: Receives the book and loan receipt.
Actors: Patron, Librarian, System

Data Stores: Book Database, Patron Database, Loan Database, Account Database


Explanation of the DFD Steps:


The Patron initiates the process by requesting to borrow a book.
The System verifies the Patron's account status (e.g., valid account, no outstanding fines).
The System checks the Book's availability (e.g., not already loaned, not reserved by another patron).
If the Patron and Book are both valid, the System creates a new Loan record in the Loan Database.
The System updates the Book's availability status in the Book Database to Loaned.
The System updates the Patron's account in the Account Database to reflect the new loan.
The System generates a loan receipt for the Patron, containing details such as the book title, due date, and loan ID.
The Patron receives the book and the loan receipt.

How this Addresses the Problem Statement:


This OOA use case demonstrates how to analyze the requirements of the online library system. By identifying objects, defining their attributes and methods, modeling their behavior over time, and mapping out the data flow for key functionalities, we can create a solid foundation for designing and implementing the system. The UML diagram, state diagram, and DFD provide visual representations that aid in understanding and communication. This analysis helps ensure that the system meets the needs of both patrons and librarians.
